<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Waveform Visualizer</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
  <!-- Include three.js and noise.js libraries -->
  <!--script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script-->
  <script src="noise.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.174.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.174.0/examples/jsm/"
      }
    }
</script>
</head>
<body>
  
  <!-- Main Script -->
  <script type = "module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Global variables
    let scene, camera, renderer, material, controls;
    const waveGroup = new THREE.Group();
    const zStart = 200;
    const zEnd = 4000;
    const numPoints = 50;      // Samples per waveform (frequency resolution)
    const waveWidth = window.innerWidth;     // Total width of each waveform
    const gap = 30;            // Gap between waveforms (time interval)
    const amplitudeScale = 100;// Scale noise output to amplitude
    const speed = 10; 

    const uniforms = {
      u_time: { value: 0.0 },
      u_lightPos: { value: [] }
    };
    // Initialize scene.
    init();
    animate(0);
    
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, zStart, zEnd);
      camera.position.set(0, 0, 0);
      camera.lookAt(new THREE.Vector3(0, 0, zStart));
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create initial waveforms.
      for (let i = 0; i < (zEnd-zStart)/gap; i++){
        let waveMesh = createWaveform(uniforms.u_time.value, i);
        waveGroup.add(waveMesh);
      }
      scene.add(waveGroup);

      const geometry = new THREE.SphereGeometry( 5, 32, 16 ); 
      const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
      const sphere = new THREE.Mesh( geometry, material );
      const sphere2 = new THREE.Mesh( geometry, material );
      sphere.position.set(300, 0, 500);
      sphere2.position.set(-300, 0, 500);
      scene.add(sphere);
      scene.add(sphere2);

      const light = new THREE.PointLight( 0xff0000, 100, 500, 0.2); //color, intensity, distance, decay
      const sphere3 = new THREE.Mesh( geometry, material );
      sphere3.position.set(50,-100,700);
      light.position.set( 50, -100, 700 );
      scene.add(sphere3);
      scene.add( light );


      const directionalLight = new THREE.DirectionalLight(  0x00ff00, 50 );
      directionalLight.position.set(-300, 0, 500);
      directionalLight.target = sphere;
      
      const directionalLight2 = new THREE.DirectionalLight( 0x00ff00, 50 );
      directionalLight2.position.set(300, 0, 500);
      directionalLight2.target = sphere2;
      scene.add(directionalLight);
      const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
      scene.add(directionalLightHelper);


      const light2 = new THREE.AmbientLight( 0x404040, 10 ); // soft white light
      scene.add( light2 );

      // const axesHelper = new THREE.AxesHelper( 10 );
      // scene.add( axesHelper );


      // controls = new OrbitControls( camera, renderer.domElement );
      // //controls.update() must be called after any manual changes to the camera's transform
      // controls.update();
    }
    
    
    // Create a single waveform mesh.
    // t: current time value (for noise offset), index: used for a slight variation per waveform.
    function createWaveform(t, index) {
      const vertexCount = numPoints * 2;  // Two vertices per frequency sample.
      const position = [];

      for (let i = 0; i < numPoints; i++){
        // Map frequency index to x coordinate.
        const x = THREE.MathUtils.mapLinear(i, 0, numPoints - 1, -waveWidth/2, waveWidth/2);
        // Compute amplitude using Perlin noise.
        const noiseVal = noise.perlin2(i * 0.1, (t + index * 0.1));
        const y = noiseVal * amplitudeScale - window.innerHeight/3;
        // Top vertex.
        position.push(new THREE.Vector3(x, y, 0));
      }

      const path = new THREE.CatmullRomCurve3(position);
      const geometry = new THREE.TubeGeometry( path, 64, 0.5, 8, false );
      const material = new THREE.MeshStandardMaterial( { color: 0x0000ff, roughness: 1 } );
      const meshLine = new THREE.Mesh( geometry, material );

      // const waveGeometry = new THREE.BufferGeometry().setFromPoints(position);
      // const meshLine = new THREE.Line(waveGeometry, material);
      meshLine.position.z = waveGroup.children.length * (gap+1) + 200;

      return meshLine;
    }
    
    // Animation loop.
    function animate(time) {
      requestAnimationFrame(animate);
      uniforms.u_time.value = time * 0.001;
      
      // Move each waveform forward along the z-axis.
      waveGroup.children.forEach(wave => {
        wave.position.z -= speed;
      });
      // When the front waveform passes a threshold, remove it and add a new one at the back.
      var numWaves = waveGroup.children.length;
      if (numWaves > 0) {
        let lastWave = waveGroup.children[numWaves-1];
        if (lastWave.position.z < zEnd - gap) {
          let newWave = createWaveform(uniforms.u_time.value, Math.random() * 10);
          waveGroup.add(newWave);
        }
        let firstWave = waveGroup.children[0];
        if (firstWave.position.z < zStart-gap) {
          waveGroup.remove(firstWave);
        }
      }
      // controls.update();
      renderer.render(scene, camera);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
