<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Split Frequency Visualizer</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.174.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.174.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';

    // Audio variables
    let audioContext, analyser, microphoneSource;
    let frequencyData;
    const FFT_SIZE = 512;
    let sampleRate, frequencyPerBin, startBinLow, endBinLow, startBinHigh, endBinHigh;

    // Three.js variables
    let scene, camera, renderer, controls;
    const waveGroupLow = new THREE.Group();
    const waveGroupHigh = new THREE.Group();
    const zStart = 200;
    const zEnd = 4000;
    const numPoints = 64;
    const waveWidth = window.innerWidth;
    const gap = 30;
    const highAmplitude = 250;
    const lowAmplitude = 100;
    const speed = 10; 

    async function initAudio() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            sampleRate = audioContext.sampleRate;
            microphoneSource = audioContext.createMediaStreamSource(stream);
            
            analyser = audioContext.createAnalyser();
            analyser.fftSize = FFT_SIZE;
            microphoneSource.connect(analyser);
            
            frequencyData = new Uint8Array(analyser.frequencyBinCount);
            frequencyPerBin = (sampleRate / 2) / analyser.frequencyBinCount;

            // Calculate frequency bins
            startBinLow = Math.floor(20 / frequencyPerBin);
            endBinLow = Math.ceil(1050 / frequencyPerBin);
            startBinHigh = Math.floor(260 / frequencyPerBin);
            endBinHigh = Math.ceil(4500 / frequencyPerBin);
        } catch(err) {
            console.error('Audio setup error:', err);
            alert('Microphone access required!');
        }
    }

    function createWaveform(startBin, endBin, yOffset, amplitudeScale, invertY) {
        const positions = [];

        for(let i = 0; i < numPoints; i++) {
            const t = i / (numPoints - 1);
            const binIndex = startBin + Math.floor(t * (endBin - startBin));
            const clampedBinIndex = Math.min(binIndex, endBin);
            const amplitude = frequencyData[clampedBinIndex] / 255;

            let x = THREE.MathUtils.mapLinear(i, 0, numPoints-1, -waveWidth, 0);
            let y = amplitude * amplitudeScale * 2;
            if (invertY) y = -y;
            y += yOffset;

            positions.push(new THREE.Vector3(x, y, 0));
        }
        
        for(let i = numPoints-2; i >= 0; i--) {
            positions.push(new THREE.Vector3(-positions[i].x, positions[i].y, 0));
        }
        
        const path = new THREE.CatmullRomCurve3(positions, false, 'chordal');
        const geometry = new THREE.TubeGeometry(path, 128, 1, 8, false); // path, num tube segments, radius, num radius segments, closed
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x00ff88, 
            roughness: 0.8,
            metalness: 0.5,
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = waveGroupLow.children.length * gap + zStart;
        return mesh;
    }

    function animate(time) {
        requestAnimationFrame(animate);
        
        if(analyser) analyser.getByteFrequencyData(frequencyData);
        
        // Update both waveform groups
        [waveGroupLow, waveGroupHigh].forEach(group => {
            group.children.forEach(wave => wave.position.z -= speed);
            
            // Add new waveform
            if(group.children.length === 0 || 
               group.children[group.children.length-1].position.z < zEnd - gap) {
                const isHighGroup = group === waveGroupHigh;
                analyser.getByteFrequencyData(frequencyData);
                const newWave = createWaveform(
                    isHighGroup ? startBinHigh : startBinLow,
                    isHighGroup ? endBinHigh : endBinLow,
                    isHighGroup ? window.innerHeight/2 : -window.innerHeight/2,
                    isHighGroup ? highAmplitude : lowAmplitude,
                    isHighGroup
                );
                group.add(newWave);
            }

            // Remove old waveforms
            if(group.children[0]?.position.z < zStart - gap) {
                group.remove(group.children[0]);
            }
        });

        renderer.render(scene, camera);
    }

    async function init() {
        await initAudio();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, zStart, zEnd);
        camera.position.set(0, 0, 0);
        camera.lookAt(new THREE.Vector3(0, 0, zStart));
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Initialize waveform groups
        scene.add(waveGroupLow);
        scene.add(waveGroupHigh);

        // Initial waveforms
        for(let i = 0; i < (zEnd-zStart)/gap; i++) {
            analyser.getByteFrequencyData(frequencyData);
            const waveLow = createWaveform(startBinLow, endBinLow, -window.innerHeight/2, lowAmplitude, false);
            waveLow.position.z = i * gap + zStart;
            waveGroupLow.add(waveLow);

            const waveHigh = createWaveform(startBinHigh, endBinHigh, window.innerHeight/2, highAmplitude, true);
            waveHigh.position.z = i * gap + zStart;
            waveGroupHigh.add(waveHigh);
        }

        const geometry = new THREE.SphereGeometry( 5, 32, 16 ); 
        const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
        const sphere = new THREE.Mesh( geometry, material );
        const sphere2 = new THREE.Mesh( geometry, material );
        sphere.position.set(300, 0, 500);
        sphere2.position.set(-300, 0, 500);
        scene.add(sphere);
        scene.add(sphere2);

        const light = new THREE.PointLight( 0xff0000, 1000, 250, 0.5); //color, intensity, distance, decay
        const sphere3 = new THREE.Mesh( geometry, material );
        sphere3.position.set(-300,-10,700);
        light.position.set(-300, -10, 700 );
        scene.add(sphere3);
        scene.add( light );


        const directionalLight = new THREE.DirectionalLight(  0x00ff00, 5 );
        directionalLight.position.set(-300, 0, 500);
        directionalLight.target = sphere;
        
        const directionalLight2 = new THREE.DirectionalLight( 0x00ff00, 5 );
        directionalLight2.position.set(300, 0, 500);
        directionalLight2.target = sphere2;
        scene.add(directionalLight);
        const directionalLightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
        scene.add(directionalLightHelper);


        const light2 = new THREE.AmbientLight( 0x404040, 1 ); // soft white light
        scene.add( light2 );
    }

    init();
    animate();
</script>
</body>
</html>